# MSA 기반 E-Commerce 애플리케이션

<aside>
💡

**언어 및 프레임워크:** Java 21, SpringBoot 3.5

**작업 기간:** 2025.11 - 2025.12

</aside>

## 1. 프로젝트 개요

### 개요

> 본 프로젝트는 대용량 트래픽 상황에서도 안정적인 처리 성능을 보장하고 유연한 확장이 가능한 MSA 기반의 E-Commerce 서비스를 설계 및 구축하는 것을 목표로 합니다.
> 
- **High Traffic Stability:** 선착순 이벤트 등 트래픽이 급증하는 상황에서도 사용자 요청을 안정적으로 처리할 수 있습니다.
- **Scalable Architecture:** 단일 모놀리식 구조의 한계를 넘어, 서비스별 독립적인 배포와 확장이 가능한 MSA 기반의 환경을 구축합니다.
- **Technical Problem Solving:** 분산 환경에서의 데이터 정합성을 보장하고, 발생할 수 있는 동시성 이슈 시나리오를 해결하여 신뢰도 높은 서비스를 구축합니다.

### **MSA 전환의 핵심 가치**

> 모놀리식 아키텍처가 가진 한계를 극복하고, 대규모 트래픽 환경에서 고가용성을 확보하기 위해 MSA를 선택했습니다.
> 
1. **장애 전파 방지 및 시스템 안정성 확보**
    - **모놀리식:** 한 프로세스에 여러 도메인이 함께 배포되어 있어, 특정 기능이나 인프라 장애가 발생하면 **인스턴스 전체 기능 장애로 번지기 쉬움**
    - MSA: 도메인별로 프로세스가 분리되어 있어, **특정 서비스 장애가 다른 서비스로 직접 전파되지 않고**, 서킷 브레이커 등을 통해 장애 전파 범위를 제한할 수 있음
2. **높은 유지보수성 및 독립적인 배포 환경**
    - **모놀로식:** 하나의 코드베이스에 여러 도메인이 강결합된 형태로, 로직 수정 시 발생할 수 있는 **파급 효과의 범위 예측이 힘들고 유지보수 난이도가 높아짐**
    - **MSA**: 도메인별로 서비스와 배포 단위가 분리되어 있어, 한 서비스 내부 로직을 수정하더라도 **변경 영향 범위가 해당 서비스로 상대적으로 제한되며**, 이를 통해 유지보수 난이도를 줄일 수 있음
3. **유연하고 효율적인 스케일관리**
    - **모놀로식**: 트래픽이 특정 기능에 몰려도 **전체 애플리케이션 인스턴스**를 통째로 늘려야 해 불필요한 자원 사용이 발생하고, **전체 코드를 한 번에 빌드·배포**해야 해서 서비스가 커질수록 빌드/배포 시간이 길어집니다.
    - **MSA**: 트래픽이 집중되는 **특정 서비스(예: 주문/결제)**만 선택적으로 Scale-out·배포할 수 있어 효율적인 자원 사용이 가능하며, **변경된 서비스만 빌드·릴리즈**하면 되므로 빌드/배포 시간과 부담을 줄일 수 있습니다.

---

---

## 2. 시스템 아키텍쳐 설계

### 핵심 구성 요소 및 역할
<img width="1282" height="721" alt="Image" src="https://github.com/user-attachments/assets/57f5853d-c447-4352-9b1d-e58ee946a73c" />

- **Microservice(Core)**
    - 사용자의 요청에 대한 비즈니스 로직을 수행하는 핵심 서비스입니다. 도메인별로 **독립적인 서비스 인스턴스와 자신만의 데이터 저장소를 소유**하며, 서비스 단위로 **별도 배포·확장**이 가능합니다.
- **API Gateway**
    - 클라이언트에게 **단일 진입점(Entry Point)** 을 제공하며, 인증/인가, 라우팅, 로드 밸런싱과 함께 **로깅, 모니터링, Rate Limiting 등 공통 운영 정책**을 중앙에서 적용합니다.
- **Service Registry**
    - 각 마이크로서비스 인스턴스의 위치(IP, PORT 등)를 **동적으로 등록·관리**하고, 헬스 체크·갱신 정보를 유지합니다. API Gateway 및 다른 마이크로서비스가 이를 조회하여 **적절한 인스턴스로 라우팅**할 수 있도록 도와줍니다.
- **Configuration Server**
    - 공통 혹은 서비스별 설정 정보를 **중앙에서 관리**하고, Git 등의 저장소를 통해 **버전 관리**를 제공합니다.
- **Messaging System**
    - 메시지 기반의 비동기 통신으로 마이크로서비스 간 결합도를 낮추고, Outbox 패턴·재시도·멱등 처리 등과 함께 사용하여 **도메인 간 데이터가 최종적으로 일관성을 확보합니다.**
- **Key-Value Store**
    - 자주 호출되는 데이터에 대한 **캐싱**, **분산락 제어**, 세션/토큰 저장, 랭킹 데이터 관리 등에 활용되어, RDB에 가해지는 부하를 줄이고 응답 속도를 개선합니다.

---

### Spring Cloud 기반 아키텍쳐 구현
<img width="1281" height="721" alt="Image" src="https://github.com/user-attachments/assets/6951746b-4d7f-4151-85f5-da792ef5c12c" />

- **Spring Boot Microservice**
    - 비지니스 로직 수행을 위한 독립적인 Microsercice는 **Spring Boot 3** 기반으로 개발되며, 서비스간 통신을 위해 RESTful API(동기)와 Kafka(비동기)를 활용합니다.
- **Spring Cloud Gateway**
    - 클라이언트 요청 단일 진입점 역할의 Edge Service구현을 위해 Spring Cloud Gateway를 활용합니다. 요청에 대한 동적 라우팅 및 필터링(인증/인가, 로깅 등)역할을 담당합니다.
- **Netflix Eureka Service Registration & Discovery**
    - 서비스 인스턴스의 등록 및 검색을 위해 **Netflix Eureka**를 사용하며, 서비스 위치 정보를 관리.제공하고 다운 인스턴스를 대상으로 로드 밸런싱을 적용합니다.
- **Spring Cloud Config Server/Client**
    - Spring Cloud Config Server/Client로 설정을 중앙에서 관리하며, Git(GitHub 등)에 설정 파일을 저장합니다. Spring Cloud Bus와 결합하면 설정 변경 내용을 각 서비스(인스턴스)로 자동 전파할 수 있습니다.
- **Kafka Messaging Broker**
    - 도메인 간 이벤트를 비동기 처리하고 분산 트랜잭션 문제를 완화하기 위해 고성능 메시지 브로커인 **Apache Kafka**를 사용합니다. Outbox 패턴과 재시도·멱등 처리를 적용해 메시지의 최소 1회 이상 발행을 보장하고, 중복 수신 시에도 비즈니스 결과가 1회 실행과 동일하도록 보장합니다.
- **Redis Key-Value Store**
    - RDB에 가해지는 부하를 분산하기 위한 In-memory 저장소로 **Redis**를 사용합니다. Redis 자료형을 활용하여 캐싱, 분산락, 대기열 기능을 제공하며 요청에 대한 응답 속도를 개선합니다.

---

---

## 3. 문제 상황과 해결

### ✅ DB와 Kafka 간 dual write로 인해 데이터 정합성 불일치 문제 발생

**[문제 상황 1.]**

- `@Transactional` 의 한계로 인해 Rollback 처리 된 트랜잭션에 대해 유령 이벤트가 발행

![Image](https://github.com/user-attachments/assets/32b6cbc8-ca96-4128-adf2-d6afd9503a37)

**[문제 상황 2.]**

- 정상적으로 Commit이 완료된 트랜잭션에 대해 이벤트 발행 중 외부 장애(네트워크, 브로커 등)로 인해 이벤트 수신에 실패하여 이벤트가 유실
![Image](https://github.com/user-attachments/assets/b12ca19b-a064-4ead-b490-de6f4f6c4758)

**[행동]**

- **Transactional Outbox 패턴 도입으로 dual write 문제 제거**
    - 비즈니스 트랜잭션 내에서 직접 Kafka로 이벤트를 발행하는 대신, 이벤트 메타 정보와 페이로드를 Outbox 테이블에 `PENDING` 상태로 먼저 기록
    - 도메인 엔티티 변경과 Outbox 레코드 생성을 하나의 로컬 트랜잭션으로 묶어 **DB 관점에서의 원자성 및 데이터 정합성**을 보장
- **Outbox 기반 at-least-once 이벤트 발행 파이프라인 구성**
    - 짧은 주기로 동작하는 Scheduler Job이 Outbox 테이블에서 `PENDING`, `FAIL` 상태 레코드를 조회하여 이벤트를 브로커(Kafka)에 발행
    - 발행 성공 시 Outbox 상태를 `SENT` 등으로 갱신해 동일 레코드에 대한 불필요한 재발행을 차단하며, 장애 발생 시 재시도가 가능하도록 설계
- **Consumer 단 멱등성(Idempotency) 검증으로 중복 처리 방지**
    - 이벤트 고유 식별자(예: `order-id`)를 기반으로 멱등성 키를 생성하고, 처리 완료된 이벤트에 대한 키를 Redis에 저장
    - 이벤트 처리 시작 전에 Redis에 저장된 멱등성 키를 검사하여 이미 처리된 이벤트는 즉시 무시함으로써, at-least-once 발행으로 인한 **중복 소비를 안전하게 차단**
 
![Image](https://github.com/user-attachments/assets/1d0cbe55-b1fe-4250-9a39-62303974daba)

**[성과]**

- 모든 발행 이벤트를 Outbox 테이블에 영속화하여, 이벤트 발행 이력 및 재처리 대상에 대한 **추적 가능성** 확보
- Outbox 기반 **at-least-once 발행**과 Consumer 단 **멱등성 보장 로직**을 결합해, 이벤트 유실·중복 처리 없이 **도메인 간 데이터 정합성** 확보
- 브로커·네트워크 일시 장애 발생 시 Outbox 재시도 메커니즘을 통해 **운영자 개입 없이 자동 복구 가능**, 장애 대응 리스크 감소

---

### ✅ 선착순 쿠폰 발급 요청에 대한 순서 보장 실패 및 동시성 이슈

**[문제 상황]**

- 선착순 쿠폰 발급 기능 테스트 중 동시성 이슈로 인해 **재고 수량을 초과하는 쿠폰 발급** 발생
- **사용자의 요청 도착 시각 기준 순차 발급이 보장되지 않아**, 선착순 정책에 대한 신뢰 저하

<img width="1282" height="722" alt="Image" src="https://github.com/user-attachments/assets/22ac4475-f435-4a37-8b78-6ccd182afa19" />

**[해결]**

- 초기에 **Redis 기반 분산락**을 적용해 동시성 이슈를 완화했으나,
    - K6 부하 테스트(선착순 쿠폰 발급 시나리오)에서 **평균 응답 시간 3s+**로 성능 개선 필요성 확인
- 이후, Redis 자료구조를 활용해 **동시성 제어와 순차 발급을 분리하는 구조로 재설계**
    - **Redis Sorted Set**을 활용해 쿠폰 발급 요청자 목록 관리
        - 사용자의 쿠폰 발급 요청 시각을 **Score로 사용**하여, 요청 순서 기반의 **정렬·조회** 보장
    - **쿠폰 재고 카운터**를 Redis String/Counter로 관리하여, 발급 가능 수량에 대한 **경량 카운팅 및 동시 차감** 처리
    - 실제 쿠폰 발급은 **@Scheduler Job을 통해 백그라운드에서 실행**
        - API 요청에서는 **발급 후보 등록까지만 처리**하여, 응답 지연 없이 비동기적으로 발급
- 쿠폰 발급이 완료되었거나 만료된 쿠폰에 대해서는,
    - 별도의 **정리용 @Scheduler Job**을 추가해 관련 Sorted Set 및 Counter 키를 정리하여 **Redis 저장소 자원 회수**

**[성과]**

- **요청 도착 순서 기준 발급**을 보장함으로써, 선착순 쿠폰 기능에 대한 **정책 신뢰성 확보**
- 동시성 제어 로직을 Redis 자료구조와 배치성 발급 처리(Job)로 분리하여, **유실되는 요청 없이 최대 발급 수량을 정확히 보장**
- K6 부하 테스트 기준, 쿠폰 발급 요청에 대한 평균 응답 시간 **약 75.5% 개선 (3325.54ms → 814.62ms)**

---

### ✅ 외부 시스템 장애 발생으로 인한 장애 전파 문제

**[문제 상황]**

- 주문 서비스와 같은 외부 마이크로서비스 장애(지연·오류) 발생 시, 이를 호출하는 사용자 서비스·결제 서비스 등 다수의 내부 서비스까지 연쇄적으로 오류가 전파되는 구조
- 외부 시스템 응답 대기 중 쓰레드가 장기간 점유되면서, 주요 API 전체의 응답 지연 및 타임아웃 증가

**[해결]**

- Resilience4J 기반 Circuit Breaker 패턴을 OpenFeign 클라이언트에 적용
    - 외부 주문 서비스 호출 구간에 대해 실패율·지연 시간 기준의 차단 임계값을 정의하고, 상태(Closed / Open / Half-Open)에 따른 보호 로직 구성
    - 장애 또는 지연 감지 시 즉시 미리 정의된 Fallback 응답(예: 주문 내역 기본 메시지, 빈 리스트 등)을 반환하여 호출 지연 최소화
- OpenFeign 인터페이스를 도메인 서비스에서 직접 의존하지 않도록 인터페이스 추상화를 추가하고, 인프라 레이어에서 Circuit Breaker 설정을 캡슐화하여 적용

<img width="582" height="208" alt="Image" src="https://github.com/user-attachments/assets/e19b1a06-23b2-483c-a039-cf880e2a2070" />

<img width="736" height="253" alt="Image" src="https://github.com/user-attachments/assets/0f623287-ea89-4da4-a64a-6b5534fd2e72" />

**[성과]**

- 외부 주문 서비스 장애 시에도 호출 서비스로의 예외 전파 및 쓰레드 고갈을 방지하여, **장애가 특정 도메인으로 국한되도록 격리하고 전체 서비스 가용성을 유지**
- 사용자는 일시적으로 주문 내역 조회가 제한되더라도, 로그인·상품 조회·결제 등 **핵심 경로는 정상 이용 가능하여 사용자 경험 저하 최소화**
- 외부 연동 로직이 추상화 계층을 통해 캡슐화되어, **서킷 브레이커 정책 변경·추가 외부 서비스 연동 시에도 코드 변경 범위가 축소**되고 유지보수성이 향상됨
- 장애 대응 관점에서, **외부 시스템 장애를 “부분 기능 저하(Graceful Degradation)”로 흡수하는 아키텍처 기반**을 마련

---

## 4. 추가 개선 가능 지점

- 배포 간소화 및 무중단 배포
    - 마이크로서비스 아키텍처 환경에서는 서비스 수가 많아질수록 **배포 단위와 인스턴스 수가 기하급수적으로 증가**한다.
    단일 서버에 WAR 파일을 올리던 방식으로는 각 서비스별 버전 관리와 롤백, 트래픽 분산, 장애 대응이 사실상 불가능해진다.
    이 문제를 해결하기 위해, 컨테이너 기술(Docker)과 컨테이너 오케스트레이션 도구(Kubernetes)를 도입해 **배포 단위를 표준화**하고, **다중 인스턴스 운영과 무중단 배포 전략(예: Rolling, Canary 배포 등)을 수립하여 배포 공수를 최소화하고 지속적으로 이용가능한 서비스를 제공**
- 분산 환경 이력 추적(트레이싱)
    - MSA 환경에서는 하나의 사용자 요청이 API Gateway와 여러 마이크로서비스, 메시지 브로커를 거치며 처리되기 때문에, 단일 서비스 로그만으로는 **어디에서 지연·오류가 발생했는지 end-to-end로 파악하기 어렵다.** Trace/Span 기반의 분산 트레이싱을 도입하고 HTTP/메시지 헤더를 통해 Trace ID를 전파함으로써, 요청 흐름을 서비스 경계를 넘어서 하나의 타임라인으로 시각화할 수 있다. 이를 통해 **데이터 정합성 문제나 성능 병목 지점을 빠르게 추적·분석하고, 장애 원인 파악 및 재현 시간을 단축**할 수 있다
- 인스턴스 자원 모니터링
    - 다중 인스턴스가 동적으로 스케일 인/아웃되는 환경에서는 개별 서버 수준이 아닌 **서비스 단위의 자원 사용량과 성능 지표(CPU, 메모리, GC, 요청 지연 시간, 에러율 등)를 통합적으로 관측**하는 체계가 필요하다. 애플리케이션 메트릭과 인프라 메트릭을 수집·대시보드화하고, 임계치 기반 알람 및 오토스케일링 정책과 연계함으로써 **자원 부족이나 과부하 징후를 사전에 감지하고, 성능 저하·장애를 예방하는 운영 기반을 마련**할 수 있다.

---

## 5. 마무리 - 마이크로서비스 아키텍처 도입에 대한 정리

- **모놀로식 vs 마이크로서비스: 확장성과 대용량 트래픽 관점**
    - 마이크로서비스 아키텍처는 서비스별로 **독립적인 배포·스케일링**이 가능해, 트래픽이 집중되는 영역만 선택적으로 확장할 수 있다.
    - 장애가 발생하더라도 전체 시스템이 함께 영향을 받기보다, **서비스 단위로 장애를 격리**할 수 있어 가용성과 복원력이 향상된다.
    - 서비스 경계를 기준으로 기술 스택과 데이터 저장소를 분리할 수 있어, **도메인 특성에 맞는 최적의 기술 선택과 성능 튜닝**이 가능하다.
- **마이크로서비스 전환 시 고려해야 할 기술적 트레이드오프**
    - 서비스 간 통신, 분산 트랜잭션, 데이터 정합성, 배포·모니터링·트레이싱 등 **운영 복잡도와 인프라 난이도는 모놀리식보다 확실히 높아진다.**
    - 네트워크 지연, 메시지 유실, 동시성 제어와 같은 이슈가 아키텍처 차원에서 항상 고려되어야 하며, 이를 위한 **추가적인 인프라와 운영 역량**이 요구된다.
- **서비스 규모와 조직 상황에 맞는 “현실적인 선택”이 중요**
    - 마이크로서비스 아키텍처는 만능 해법이 아니라, **서비스 규모·트래픽 특성·팀의 조직 구조와 역량**에 따라 효과가 달라지는 선택지 중 하나이다.
    - 현재 시스템의 복잡도와 성장 속도를 고려해, 모놀리식 개선 → 모듈화 → 점진적 분리와 같은 **단계적인 전환 전략**이 필요하다.
    - 결국 아키텍처는 목표가 아니라 **비즈니스 가치를 안정적으로, 확장 가능하게 전달하기 위한 수단**이라는 관점을 유지하는 것이 중요하다.
